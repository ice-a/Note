spec2006 429.mcf统计

|         | x86->sw64 | sw64->sw64 |
| ------- | --------- | ---------- |
| in_asm  | 10225     | 12257      |
| op      | 62664     | 38791      |
| op_opt  | 47315     | 33846      |
| out_asm | 106787    | 97720      |

121  999

|      | x86->sw64 | sw64->sw64 |
| ---- | --------- | ---------- |
| 带优化  | 3.83      |            |
| 不带优化 |           |            |
|      |           |            |

|     | 114<br/>x86->sw64 | 121<br/>sw64->sw64 |
| --- | ----------------- | ------------------ |
|     |                   |                    |
|     |                   |                    |
|     |                   |                    |

# 优化思路

一、指令数量优化，后端为何得到的指令相对更多？

中间代码翻译质量较差，导致后端翻译时指令膨胀率很高

二、helper函数？

call zapnot为何不翻译要调helper函数，x86->sw就后端就有zapnot指令，自己的思路与罗姐思路重合

sw->sw系统调用是抛出异常，调helper函数实现的，x86->sw是通过helper函数实现的。都是helper，位置不同

三、中间代码优化思路

前：ldi，ldih --- 中：add ----后：add
添加中间码ldi，ldih

前：addw --- 中：add_i64,ext32s_i64
改成add_i32

四
ldl -> add， qemu_ld 优化为 qemu_ld重新添加一条符合申威的qemu_ld中间码

五、
前：andi 0xfffff 大数sw不好存，中间码添加一条bic a & not b 取反保存好保存

六、
translate_one 中截取各个部分可以推迟

七、
gen_tb_start ld_i32 brcond_i32 是32位操作，而我们是64位机器，因此改成64位，放大结构体

八、
add -1 改成 sub 1 ，申威保存-1比较麻烦。

九、
所有操作码为0x12的都是立即数格式的简单运算指令格式，前端都把立即数放入临时变量处理？改成常量？
虽然是临时变量，但后端翻译时会匹配格式，把它作为常量处理，两者效率差异？