# 性能分析

spec2006 429.mcf统计

|         | x86->sw64 | sw64->sw64 |
| ------- | --------- | ---------- |
| in_asm  | 10225     | 12257      |
| op      | 62664     | 38791      |
| op_opt  | 47315     | 33846      |
| out_asm | 106787    | 97720      |

# 优化思路

一、指令数量优化，后端为何得到的指令相对更多？

中间代码翻译质量较差，导致后端翻译时指令膨胀率很高

二、helper函数？

call zapnot为何不翻译要调helper函数，x86->sw就后端就有zapnot指令，自己的思路与罗姐思路重合

sw->sw系统调用是抛出异常，调helper函数实现的，x86->sw是通过helper函数实现的。都是helper，位置不同

三、中间代码优化思路

前：ldi，ldih --- 中：add ----后：add
添加中间码ldi，ldih

~~前：addw --- 中：add_i64,ext32s_i64
改成add_i32~~

四、存储装入指令优化
ldl -> add， qemu_ld 。
LDBU、LDHU、LDW、LDL、STB、STH、STW、STL、FLDD、FSTD翻译为qemu自带的ld中间码
LDL_U、STL_U、FLDS、FSTS翻译为添加的符合申威定义的中间码

五、
前：andi 0xfffff 大数sw不好存，中间码添加一条bic a & not b 取反保存好保存

六、
translate_one 中截取各个部分可以推迟到case中，特殊情况ra=r31可以提前到case之后，截取之前。

七、
gen_tb_start ld_i32 brcond_i32 是32位操作，而申威是64位，因此改成64位，放大结构体。

八、
add -1 改成 sub 1 ，申威保存-1比较麻烦。

九、
所有操作码为0x12的都是立即数格式的简单运算指令格式，前端都把立即数放入临时变量处理？改成常量？
虽然是临时变量，但后端翻译时会匹配格式，把它作为常量处理，两者效率差异？

十、简单运算指令格式的指令
寄存器格式与立即数格式在前端的处理一致，区别在立即数格式会把立即数放入一个临时变量中（中间码多一条mov）。随后在中间码优化过程中，如果中间码操作数约束满足寄存器与立即数，则会将这一条mov优化掉（常量传播）。因此，中间码约束定义要有寄存器与立即数。
如果在前端就将两种格式分开处理，则中间优化可以省一些时间及空间。优化效果未知。可能会导致中间优化出错？

十一、
mov 存大数，步骤
1、超过32的数，先ldi存入寄存器，然后sll 0x20
2、16~32位的数，ldih放入高位
3、0~16位的数，ldi放入低位
其中有两种做法1、ldih与ldi全部加整数。2、ldih多加1，ldi加负数。 两种做法效果相同，但2做法ldi能加一个较小负数。

十二、
INDEX_op_ldi后端翻译时存在一种情况，上文中立即数已被放入寄存器中（ldi $rx , imm），此时不能翻译为ldi，要翻译为addl寄存器相加。

十三、
中间代码优化中，不考虑常量参数，因此ldi、ldih还是得仿照add定义。
